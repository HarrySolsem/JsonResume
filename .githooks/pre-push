#!/bin/bash
set -euo pipefail

# Get the root directory of the Git repository.
REPO_ROOT=$(git rev-parse --show-toplevel || { echo "Error: Not inside a Git repository." >&2; exit 1; })
LOG_FILE="$REPO_ROOT/.git-pre-push.log"

# Default values for variables.
DEBUG_MODE = "false"

# Log function to print to stdout and append to a log file.
log() {
  local level="$1"
  local message="$2"
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local output="[$timestamp] $level $message"
  echo "$output" | tee -a "$LOG_FILE"
}

# Debug log that only outputs when DEBUG_MODE is true.
debug_log() {
  if [ "$DEBUG_MODE" = "true" ]; then
    log "[DEBUG]" "$1"
  fi
}

# Ensure prerequisites are met.
check_prerequisites() {
  if ! command -v jq &> /dev/null; then
    log "[ERROR]" "jq is not installed. Please install jq (e.g., 'sudo apt install jq')."
    exit 1
  fi

  if [ ! -d "$REPO_ROOT/resumes" ]; then
    log "[ERROR]" "Resumes directory not found at $REPO_ROOT/resumes."
    exit 1
  fi
}

# Validate that a JSON file is correctly formatted.
validate_json_file() {
  local file="$1"
  if ! jq empty "$file" &> /dev/null; then
    log "[ERROR]" "Invalid JSON in file: $file"
    exit 1
  fi
}

# Read config from the JSON file.
read_config() {
  CONFIG_FILE="$REPO_ROOT/config.json"
  if [ -f "$CONFIG_FILE" ]; then
    validate_json_file "$CONFIG_FILE"
    
    # Use the // operator to default to empty if a key is missing.
    TARGET_RESUMETYPE=$(jq -r '.deployment.resumetype // empty' "$CONFIG_FILE")
    TARGET_LANGUAGE=$(jq -r '.deployment.language // empty' "$CONFIG_FILE")
    DRY_RUN=$(jq -r '.environment.dryrun // empty' "$CONFIG_FILE")
    DEBUG_MODE=$(jq -r '.environment.debug // empty' "$CONFIG_FILE")
    
    if [ -z "$TARGET_RESUMETYPE" ]; then
      log "[ERROR]" "Missing key 'deployment.resumetype' in $CONFIG_FILE."
      exit 1
    fi
    if [ -z "$TARGET_LANGUAGE" ]; then
      log "[ERROR]" "Missing key 'deployment.language' in $CONFIG_FILE."
      exit 1
    fi
    if [ -z "$DRY_RUN" ]; then
      log "[ERROR]" "Missing key 'deployment.dryrun' in $CONFIG_FILE."
      exit 1
    fi
    
    log "[INFO]" "Config read: resumetype='$TARGET_RESUMETYPE', language='$TARGET_LANGUAGE', dryrun='$DRY_RUN'"
  else
    log "[WARNING]" "deployment-config.json not found. Defaulting to resumetype: master, language: no, dryrun: 0."
    TARGET_RESUMETYPE="master"
    TARGET_LANGUAGE="no"
    DRY_RUN="0"
  fi
}

# Find a matching resume file based on the config.
find_resume_file() {
  FOUND_SOURCE_FILE=""
  for resume_file in "$REPO_ROOT/resumes"/*.json; do
    if [ -f "$resume_file" ]; then
      validate_json_file "$resume_file"
      
      local file_resumetype file_language
      file_resumetype=$(jq -r '.meta.resumetype // empty' "$resume_file")
      file_language=$(jq -r '.meta.language // empty' "$resume_file")
      
      if [ "$file_resumetype" == "$TARGET_RESUMETYPE" ] && [ "$file_language" == "$TARGET_LANGUAGE" ]; then
        if [ -n "$FOUND_SOURCE_FILE" ]; then
          log "[WARNING]" "Multiple resume files match the criteria. Using the first match: $FOUND_SOURCE_FILE"
          break
        fi
        FOUND_SOURCE_FILE="$resume_file"
        log "[INFO]" "Found matching resume file: $FOUND_SOURCE_FILE"
      fi
    fi
  done

  if [ -z "$FOUND_SOURCE_FILE" ]; then
    log "[ERROR]" "No resume file found matching resumetype: $TARGET_RESUMETYPE and language: $TARGET_LANGUAGE."
    exit 1
  fi
}

# Copy the found resume file, stage it, and commit if changes exist.
commit_changes() {
  DEST_FILENAME="resume.json"
  DEST_FILE="$REPO_ROOT/$DEST_FILENAME"

  cp "$FOUND_SOURCE_FILE" "$DEST_FILE"
  log "[INFO]" "Copied $(basename "$FOUND_SOURCE_FILE") to $DEST_FILE"
    
  if [ "$DRY_RUN" == "1" ]; then
    log "[INFO]" "Dry run mode enabled. No commit will be made."
    exit 0
  fi

  git add "$DEST_FILE"
  if git diff --cached --quiet "$DEST_FILE"; then
    log "[INFO]" "No changes detected in $DEST_FILE. Nothing to commit."
  else
    COMMIT_MSG=${COMMIT_MESSAGE:-"Auto-update resume.json from $(basename "$FOUND_SOURCE_FILE")"}
    log "[INFO]" "Preparing to commit with message: $COMMIT_MSG"
    if [ -n "${GIT_AUTHOR_NAME:-}" ]; then
      log "[INFO]" "Using embedded identity for commit."
      git commit -m "$COMMIT_MSG" -- "$DEST_FILE"
    else
      log "[INFO]" "Using Git config identity for commit."
      git -c "user.name=$GIT_USERNAME" -c "user.email=$GIT_EMAIL" commit -m "$COMMIT_MSG" -- "$DEST_FILE"
    fi
  fi
}

# Set Git identity fallback if not fully configured.
GIT_USERNAME=$(git config user.name || echo "")
GIT_EMAIL=$(git config user.email || echo "")
if [ -z "$GIT_USERNAME" ] || [ -z "$GIT_EMAIL" ]; then
  log "[WARNING]" "Git identity is not fully configured. Falling back to embedded identity."
  GIT_USERNAME="Pre-Push Hook"
  GIT_EMAIL="pre-push-hook@localhost"
  export GIT_AUTHOR_NAME="$GIT_USERNAME"
  export GIT_AUTHOR_EMAIL="$GIT_EMAIL"
  export GIT_COMMITTER_NAME="$GIT_USERNAME"
  export GIT_COMMITTER_EMAIL="$GIT_EMAIL"
fi

# Initial logging and debugging.
log "[INFO]" "Starting pre-push hook."
log "[INFO]" "Repository root: $REPO_ROOT"
debug_log "Current working directory: $(pwd)"
debug_log "User: $(whoami)"
debug_log "Script: $0"

# Ensure the log file exists.
if [ ! -f "$LOG_FILE" ]; then
  touch "$LOG_FILE"
  log "[INFO]" "Log file created at $LOG_FILE"
fi

# Run the steps.
check_prerequisites
read_config
find_resume_file
commit_changes

log "[INFO]" "Pre-push hook completed successfully."
exit 0
