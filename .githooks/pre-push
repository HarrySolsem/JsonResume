#!/bin/bash

# Git pre-push hook that reads deployment.resumetype and deployment.language from deployment-config.json
# and finds a matching resume file based on meta.language and meta.resumetype properties
# The content of this file must be copied to .git/hooks/pre-push file.

# Metadata
# Version number: 1.2
# Date: 2025-04-23

# Store the root directory of the git repository
REPO_ROOT=$(git rev-parse --show-toplevel || { log "Error" "Not inside a Git repository"; exit 1; })

LOG_FILE="$REPO_ROOT/.git-pre-push.log"

# This script is intended to be run as a pre-push hook in a Git repository.

log() {
  #Do the actual logging to file and stdout
  local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1 $2"
  echo "$message" >> "$LOG_FILE"
  echo "$message"
}

#debug information
log "[DEBUG]" "Current working directory: $(pwd)"
log "[DEBUG]" "User: $(whoami)"
log "[DEBUG]" "PATH: $PATH"
log "[DEBUG]" "SHELL: $SHELL"

log "[DEBUG]" "Script location: $0"
log "[DEBUG]" "Script directory: $(dirname "$0")"




#make sure the log file is created in the root of the repository
if [ ! -f "$LOG_FILE" ]; then
    log "INFO" "Log file not found. Creating log file: $LOG_FILE"
    touch "$LOG_FILE"
    log "[INFO]" "log file created: $LOG_FILE"
fi

log "[INFO]" "Log file: $LOG_FILE"
log "[INFO]" "Repository root: $REPO_ROOT"

log "[INFO]" "Using pre-push from .githooks folder"
# Exit on any error
set -euo pipefail

# Get the Git username and email from the repo config
GIT_USERNAME=$(git config user.name)
GIT_EMAIL=$(git config user.email)

#Initialize variables for Git identity to empty strings
GIT_AUTHOR_NAME=""
GIT_AUTHOR_EMAIL=""
GIT_COMMITTER_NAME=""
GIT_COMMITTER_EMAIL=""

# Check if Git identity is available
if [ -z "$GIT_USERNAME" ] || [ -z "$GIT_EMAIL" ]; then
  log "[WARNING]" "Git identity not fully configured. Using the pre-push hook's embedded identity."
  # Use hardcoded values as a fallback
  GIT_USERNAME="Pre-Push Hook"
  GIT_EMAIL="pre-push-hook@localhost"
  
  # Temporarily set the identity for this command only
  export GIT_AUTHOR_NAME="$GIT_USERNAME"
  export GIT_AUTHOR_EMAIL="$GIT_EMAIL"
  export GIT_COMMITTER_NAME="$GIT_USERNAME"
  export GIT_COMMITTER_EMAIL="$GIT_EMAIL"
fi

# Check if a config file exists and read deployment information from it
CONFIG_FILE="$REPO_ROOT/config.json"
#CONFIG_FILE="$REPO_ROOT/deployment-config.json"

if [ -f "$CONFIG_FILE" ]; then
  # Check if jq is installed
  if ! command -v jq &> /dev/null; then
    log "[ERROR]" "jq is not installed. Please install jq to parse JSON files."
    exit 1
  fi

  #debug information
  log "[DEBUG]" "Absolute config file path: $(realpath "$CONFIG_FILE")"
  log "[DEBUG]" "File exists check: $([ -f "$CONFIG_FILE" ] && echo "YES" || echo "NO")"

  log "[DEBUG]" "File contents (first 50 chars): $(head -c 50 "$CONFIG_FILE" 2>/dev/null || echo 'CANNOT READ FILE')"
  
  # Read deployment.resumetype and deployment.language from JSON file
  log "[INFO]" "Before reading deployment-config.json for resumetype and language"
  jq -r '.deployment.resumetype' "$CONFIG_FILE"
  #TARGET_RESUMETYPE=$(jq -r '.deployment.resumetype' "$CONFIG_FILE")
  #TARGET_LANGUAGE=$(jq -r '.deployment.language' "$CONFIG_FILE")
  log "[INFO]" "After reading deployment-config.json for resumetype and language"
  
  if [ "$TARGET_RESUMETYPE" == "null" ] || [ "$TARGET_LANGUAGE" == "null" ]; then
    log "[ERROR]" "Unable to read deployment.resumetype or deployment.language from $CONFIG_FILE"
    exit 1
  fi
  
  log "[INFO]" "Looking for resume with resumetype: $TARGET_RESUMETYPE and language: $TARGET_LANGUAGE"
else
  # Default values if no config file exists
  log "[WARNING]" "deployment-config.json not found. Defaulting to resumetype: master and language: no."
  TARGET_RESUMETYPE="master"
  TARGET_LANGUAGE="no"
fi

# Find the matching resume file in the resumes directory
FOUND_SOURCE_FILE=""
for resume_file in "$REPO_ROOT/resumes"/*.json; do
  if [ -f "$resume_file" ]; then
    RESUMETYPE=$(jq -r '.meta.resumetype' "$resume_file")
    LANGUAGE=$(jq -r '.meta.language' "$resume_file")
    
    if [ "$RESUMETYPE" == "$TARGET_RESUMETYPE" ] && [ "$LANGUAGE" == "$TARGET_LANGUAGE" ]; then
      FOUND_SOURCE_FILE="$resume_file"
      log "[INFO]" "Found matching resume file: $resume_file"
      break
    fi
  fi
done

if [ -z "$FOUND_SOURCE_FILE" ]; then
  log "[ERROR]" "Could not find a resume file matching resumetype: $TARGET_RESUMETYPE and language: $TARGET_LANGUAGE"
  exit 1
fi

# Extract just the filename from the full path
SOURCE_FILENAME=$(basename "$FOUND_SOURCE_FILE")
log "[INFO]" "Using source file: $SOURCE_FILENAME"

# Define source and destination files
SOURCE_FILE="$REPO_ROOT/resumes/$SOURCE_FILENAME"
DEST_FILENAME="resume.json"
DEST_FILE="$REPO_ROOT/$DEST_FILENAME"

# Copy the file
log "[INFO]" "Copying $SOURCE_FILE to $DEST_FILE"
cp "$SOURCE_FILE" "$DEST_FILE"

# Add the destination file to the git staging area
git add "$DEST_FILE"

# Check if there are changes to commit
if git diff --cached --quiet "$DEST_FILE"; then
  log "[INFO]" "No changes to commit for $DEST_FILE"
else
  # Commit the changes with explicit identity
  log "[INFO]" "Committing changes to $DEST_FILE"
  if [ -n "$GIT_AUTHOR_NAME" ]; then
    # Use the environment variables we set
    log "[INFO]" "Using embedded identity for commit"
    git commit -m "Auto-update resume.json from $SOURCE_FILENAME" -- "$DEST_FILE"
  else
    # Use the config values directly
    log "[INFO]" "Using config identity for commit"
    git -c "user.name=$GIT_USERNAME" -c "user.email=$GIT_EMAIL" commit -m "Auto-update resume.json from $SOURCE_FILENAME" -- "$DEST_FILE"
  fi
fi

# Continue with the push
log "[INFO]" "Pre-push hook completed successfully."
exit 0