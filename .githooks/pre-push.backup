#!/usr/bin/env node

// Git pre-push hook with async operations
const fs = require('fs').promises;  // Use the promises version of fs
const path = require('path');
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);  // Promisify exec for async usage

// Get the repo root asynchronously
async function getRepoRoot() {
  try {
    const { stdout } = await exec('git rev-parse --show-toplevel');
    return stdout.trim();
  } catch (error) {
    await log('ERROR', 'Not inside a Git repository. Ensure the script is executed within a valid Git workspace.');
    process.exit(1);
  }
}

// Log function with async file operations
async function log(level, message) {
const timestamp = new Intl.DateTimeFormat('en-US', {  year: 'numeric',  month: '2-digit',  day: '2-digit',  hour: '2-digit',  minute: '2-digit',  second: '2-digit',  hour12: false }).format(new Date());
const logMessage = `[${timestamp}] [${level}] ${message}`;
  
  try {
    // Check if log file exists
    try {
      await fs.access(LOG_FILE);
    } catch {
      await fs.writeFile(LOG_FILE, `[${timestamp}] [INFO] Log file created: ${LOG_FILE}\n`);
    }
    
    // Write to log file asynchronously
    await fs.appendFile(LOG_FILE, logMessage + '\n');
    
    // Write to stdout
    console.log(logMessage);
  } catch (error) {
    console.error(`Failed to write to log: ${error.message}`);
  }
}

// Get Git identity asynchronously
async function getGitIdentity() {
  try {
    const [usernameRes, emailRes] = await Promise.all([
      exec('git config user.name'),
      exec('git config user.email')
    ]);
    
    return { 
      username: usernameRes.stdout.trim(), 
      email: emailRes.stdout.trim() 
    };
  } catch (error) {
    return { username: '', email: '' };
  }
}

// Check file changes asynchronously
async function checkFileChanges(filePath) {
  try {
    await exec(`git diff --cached --quiet "${filePath}"`);
    return false; // No changes
  } catch (error) {
    return true; // Changes detected
  }
}

// Declare LOG_FILE globally
let LOG_FILE;


// Main function with async operations
async function main() {
  // Get repository root
  const REPO_ROOT = await getRepoRoot();
  LOG_FILE = path.join(REPO_ROOT, '.git-pre-push.log');
  
  await log('INFO', `Log file: ${LOG_FILE}`);
  await log('INFO', `Repository root: ${REPO_ROOT}`);
  await log('INFO', 'Using pre-push from .githooks folder (Async Node.js version)');
  
  // Get Git identity asynchronously
  const { username: gitUsername, email: gitEmail } = await getGitIdentity();
  
  // Set Git identity environment variables for commits
  const env = { ...process.env };
  let useEnvVars = false;
  
  if (!gitUsername || !gitEmail) {
    await log('WARNING', 'Git identity not fully configured. Using the pre-push hook\'s embedded identity.');
    env.GIT_AUTHOR_NAME = 'Pre-Push Hook';
    env.GIT_AUTHOR_EMAIL = 'pre-push-hook@localhost';
    env.GIT_COMMITTER_NAME = 'Pre-Push Hook';
    env.GIT_COMMITTER_EMAIL = 'pre-push-hook@localhost';
    useEnvVars = true;
  }
  
  // Check if config file exists and read source filename from it asynchronously
  const configFile = path.join(REPO_ROOT, '.resume-config');
  let sourceFilename;
  
  try {
    // Check if the config file exists
    await fs.access(configFile);
    sourceFilename = (await fs.readFile(configFile, 'utf8')).trim();
    validateFilename(sourceFilename);
  } catch (error) {
    // Default to master.no.json if no config file exists
    await log('WARNING', '.resume-config not found. Defaulting to master.no.json.');
    sourceFilename = 'master.no.json';
  }
  
  await log('INFO', `Pushing with this source file: ${sourceFilename}`);
  
  // Define source and destination files
  const sourceFile = path.join(REPO_ROOT, 'resumes', sourceFilename);
  const destFilename = 'resume.json';
  const destFile = path.join(REPO_ROOT, destFilename);
  
  // Check if source file exists asynchronously
  try {
    await fs.access(sourceFile);
  } catch {
    await log('ERROR', `Source file ${sourceFile} does not exist.`);
    process.exit(1);
  }
  
  // Copy the file asynchronously
  await log('INFO', `Copying ${sourceFile} to ${destFile}`);
  await fs.copyFile(sourceFile, destFile);
  
  // Add the destination file to the git staging area
  await exec(`git add "${destFile}"`);
  
  // Check if there are changes to commit
  if (!(await checkFileChanges(destFile))) {
    await log('INFO', `No changes to commit for ${destFile}`);
  } else {
    // Commit the changes with explicit identity
    await log('INFO', `Committing changes to ${destFile}`);
    const commitMessage = `Auto-update resume.json from ${sourceFilename}`;
    
    if (useEnvVars) {
      // Use the environment variables we set
      await log('INFO', 'Using embedded identity for commit');
      await exec(`git commit -m "${commitMessage}" -- "${destFile}"`, { env });
    } else {
      // Use the config values directly
      await log('INFO', 'Using config identity for commit');
      await exec(`git -c "user.name=${gitUsername}" -c "user.email=${gitEmail}" commit -m "${commitMessage}" -- "${destFile}"`);
    }
  }
  
  // Continue with the push
  await log('INFO', 'Pre-push hook completed successfully.');
  return 0;
}

// Keep the validateFilename function (synchronous is fine here)
function validateFilename(filename) {
  // Validate the filename for security issues
  if (!/^[a-zA-Z0-9._-]+$/.test(filename)) {
    console.error('ERROR: Invalid filename detected in .resume-config.');
    process.exit(1);
  }
  
  // Check for directory traversal patterns
  if (/(\.\.|^\.\.\/)/g.test(filename)) {
    console.error('ERROR: Invalid filename detected in .resume-config. Directory traversal patterns are not allowed.');
    process.exit(1);
  }
  
  return true;
}

// Run the main function and handle any errors
main().catch(async (error) => {
  await log('ERROR', `Unexpected error: ${error.message}`);
  process.exit(1);
});